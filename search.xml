<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Cpp-Containers</title>
      <link href="/2023/12/11/cpp-containers/"/>
      <url>/2023/12/11/cpp-containers/</url>
      
        <content type="html"><![CDATA[<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://en.cppreference.com/w/">cpp reference</a></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="关于类"><a href="#关于类" class="headerlink" title="关于类"></a>关于类</h3><ul><li><p>空类的字节数是1;</p></li><li><p>一个类中,只有非静态成员变量才属于这个类的对象</p></li><li><p>静态成员函数和非静态成员函数以及静态成员变量均不属于这个对象</p></li><li><p>自定义数据类型存在内存对齐操作</p></li><li><p>在成员函数后面加const,修饰的是this指向,让指针指向的值也不可以修改</p></li><li><p>如果在成员属性前面加上mutable,可以在常函数,常对象下修改</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mutable int a;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>常对象只能调用常函数（因为非常函数是可以修改属性的,常对象不允许修改属性）</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public://如果利用成员函数重载左移运算符//明显不能利用成员函数重载,只能用全局函数重载//void operator&lt;&lt;(cout)//p&lt;&lt;cout//{//}int m_a;int m_b;};ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p){cout &lt;&lt; "m_a= " &lt;&lt; p.m_a &lt;&lt; "m_b" &lt;&lt; p.m_b;return cout;}//cout&lt;&lt;p1&lt;&lt;endl;//返回cout是为了cout&lt;&lt;p1后面的&lt;&lt;可以继续使用;//cout只能有一个//所以cout在传入和返回的时候只能采用引用的fan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="++运算符重载"></a>++运算符重载</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Myint{friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Myint a);public:Myint():a(0){}//前置//返回引用是为了一直对一个数据进行操作,比如++(++a)Myint&amp; operator++(){a++;return *this;}Myint operator++(int)//int代表占位参数,可以区分前置和后置//不能返回引用{Myint temp=*this;++(this-&gt;a);return temp;//先 记录当时结果//后递增//最后将记录结果返回}private:int a;};ostream&amp; operator&lt;&lt;(ostream&amp; cout, Myint a)//返回临时变量,不能取引用{cout &lt;&lt; a.a;return cout;}void test01(){Myint a;cout &lt;&lt; a++ &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>类私有成员可以被类成员函数访问,不区分成员在哪个实例里</p></li><li><p>类型转换后指针的指向不变(运行时类型不变),但是编译的时候会变成另一个类型(编译时类型)</p></li><li><p>相当于只是用了另一个角度来看待这个指针</p></li></ul><blockquote><p>也就是说</p><p>如果person是父类指针当他指向子类对象还是保存的子类对象的地址</p><p>但是因为指针类型是父类所以只能访问父类成员</p><p>相当于限制访问,只能访问继承的东西,因为有继承关系子类对象一定有父类成员</p><p>所以可以用父类指针指向子类对象但是不能用子类指针指向父类对象</p><p>父类并不包含子类,所以子类指针指向父类对象会引起编译器的错误认识，容易调用子类独有的成员</p><p>当发生强制转换指向子类对象的父类指针强制转换成子类指针就只是改变了看待指针的角度,指针本身没变。</p><p>而此时指针可以访问子类的成员,不管怎么转换,地址的内容不变</p></blockquote><ul><li>成员对象初始化，先客人再自己，析构先自己再客人</li></ul><blockquote><ul><li>常量，引用，对象成员的初始化要在成员初始化表中进行，不可以直接=赋值，与位置无关，都是先客人再自己</li><li>析构都是先自己再客人</li></ul></blockquote><ul><li>初始化列表无顺序</li></ul><blockquote><p>列表中的成员初始化器的顺序是不相关的：初始化的实际顺序如下:</p><ul><li><ol><li>如果构造函数是最终派生类的，那么按基类声明的深度优先、从左到右的遍历中的出现顺序（从左到右指的是基说明符列表中所呈现的），初始化各个虚基类</li></ol></li><li><ol start="2"><li>然后，以在此类的基类说明符列表中出现的从左到右顺序，初始化各个直接基类</li></ol></li><li><ol start="3"><li>然后，以类定义中的声明顺序，初始化各个非静态成员。</li></ol></li><li><ol start="4"><li>最后，执行构造函数体（注意：如果初始化的顺序是由不同构造函数中的成员初始化器列表中的出现所控制，那么析构函数就无法确保销毁顺序是构造顺序的逆序了–&gt;</li></ol></li></ul></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Arraytype b[4]={Arraytype(1,2),Arraytype(1,2),Arraytype(1,2),Arraytype(1,2)};数组元素初始化Arraytype b[4];//缺省构造函数Arraytype b[4]={1,2,3,4};//调用一个参数构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>读文件并不会创建文件</p></li><li><p>写文件会创建文件</p><blockquote><p>也就是说 使用ofs.open之后,ofs.is_open就会失效,判断文件是否存在用ifs</p></blockquote></li></ul><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><h4 id="容器-vector"><a href="#容器-vector" class="headerlink" title="容器:vector;"></a>容器:vector;</h4><p>vector数据结构和数组非常相似,也称为单端数组,可以动态扩展</p><h4 id="算法-for-each"><a href="#算法-for-each" class="headerlink" title="算法:for_each;"></a>算法:for_each;</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public:Person(string name, int age) :m_Name(name), m_age(age){}string m_Name;int m_age;};void print(Person s){cout &lt;&lt; s.m_Name &lt;&lt; " " &lt;&lt; s.m_age &lt;&lt; endl;}for_each(v.begin(), v.end(), print);//只需要函数名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="迭代器-vector-iterator"><a href="#迭代器-vector-iterator" class="headerlink" title="迭代器:vector::iterator;"></a>迭代器:vector<t>::iterator;</t></h4><h4 id="类似动态数组"><a href="#类似动态数组" class="headerlink" title="类似动态数组"></a>类似动态数组</h4><p>动态分配内存，并不是原有空间下分配，而是找一个新空间，将原有数据拷贝到新空间下，然后释放掉原有空间</p><h3 id="容器嵌套容器"><a href="#容器嵌套容器" class="headerlink" title="容器嵌套容器:"></a>容器嵌套容器:</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//容器嵌套容器vector&lt;vector&lt;int&gt;&gt;v;//创建小容器vector&lt;int&gt;v1;vector&lt;int&gt;v2;vector&lt;int&gt;v3;vector&lt;int&gt;v4;//向小容器添加数据for (int i = 0; i &lt; 4; i++){v1.push_back(i + 1);v2.push_back(i + 2);v3.push_back(i + 3);v4.push_back(i + 4);}//将小容器插入到大容器v.push_back(v1);v.push_back(v2);v.push_back(v3);v.push_back(v4);//通过大容器，把所有数据遍历一遍for (vector&lt;vector&lt;int&gt;&gt;::iterator it = v.begin(); it != v.end(); it++){for (vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++){cout &lt;&lt; *vit;}cout &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数:"></a>构造函数:</h3><p>vector<t> v;//默认构造函数</t></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v1;//默认构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>vector<t>(v.begin(),v.end());//将v[begin(),end())区间中的元素拷贝给本身，左闭右开</t></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[10];vector&lt;int&gt;v2(a, a+10);//左闭右开的区间构造 可以放迭代器也可以放指针 会发生隐式转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>vector<t>(n,elem);//构造函数将n个elem拷贝给本身</t></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v3(10, 100);//十个一百初始化<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>vector<t>(const vector &amp;vec);//拷贝构造函数</t></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v4(v3);//拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作:"></a>赋值操作:</h3><p>vector&amp; operator=(const vector &amp;vec);//重载等号运算符</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v1;for (int i = 0; i &lt; 10; i++){v1.push_back(i);}vector&lt;int&gt;v2;v2 = v1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身，左闭右开</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v3;v3.assign(v1.begin(), v1.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>assign(n,elem);//将n个elem拷贝复制给本身</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v4;v4.assign(10, 100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="容量和大小"><a href="#容量和大小" class="headerlink" title="容量和大小:"></a>容量和大小:</h3><p>empty();//判断容器是否为空</p><p>capacity();//容器的容量</p><p>size();//返回容器中元素的个数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v1;for (int i = 0; i &lt; 10; i++){v1.push_back(i);}if (v1.empty())//为真代表容器为空{cout &lt;&lt; "v1为空" &lt;&lt; endl;}else{cout &lt;&lt; "v1不为空" &lt;&lt; endl;cout &lt;&lt; "v1的容量" &lt;&lt; v1.capacity() &lt;&lt; endl;cout &lt;&lt; "v1的元素个数" &lt;&lt; v1.size() &lt;&lt; endl;//容量大于大小}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>resize(int num);//重新指定容器的长度为num,若容器变长,则以默认值填充新位置</p><p>//如果容器变短,则末尾超出容器长度的元素被删除</p><p>resize(int num,elem);//重新指定容器的长度为num,若容器变长,则以elem值填充新位置</p><p>//如果容器变短,则末尾超出容器长度的元素被删除</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">v1.resize(15);for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;v1.resize(25, 10);for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;v1.resize(10);for_each(v1.begin(), v1.end(), print);//大了添加默认值，小了删除尾部多余的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除:"></a>插入和删除:</h3><p>push_back(ele);//尾部插入元素ele</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;int&gt;v1;for (int i = 0; i &lt; 10; i++){v1.push_back(i);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pop_back();//删除最后一个元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(int a){cout &lt;&lt; a &lt;&lt; " ";}v1.pop_back();for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>insert(const_iterator pos,ele);//迭代器指向位置pos插入元素ele</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v1.insert(v1.begin()+1, 100);for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>insert(const_iterator pos,int count,ele);//迭代器指向位置pos插入count个元素ele</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v1.insert(v1.begin(), 2, 1000);for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>erase(const_iterator pos);//删除迭代器指向的元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v1.erase(v1.begin());for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>erase(const_iterator start,const_iterator end);//删除迭代器从start到end之间的元素,左闭右开</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v1.erase(v1.begin(), v1.begin() + 2);//左闭右开for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>clear();//删除容器中所有元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v1.clear();for_each(v1.begin(), v1.end(), print);cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取:"></a>数据存取:</h3><p>at(int idx);//返回索引idx所指的数据</p><p>operator[];//返回索引idx所指的数据</p><p>front();//返回容器中第一个数据元素</p><p>back();//返回容器中最后一个数据元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(int a){cout &lt;&lt; a &lt;&lt; " ";}vector&lt;int&gt;v1;for (int i = 0; i &lt; 10; i++){v1.push_back(i);}   for_each(v1.begin(), v1.end(), print);   cout &lt;&lt; endl;   cout &lt;&lt; v1.at(1);   cout &lt;&lt; endl;   cout &lt;&lt; v1[1];   cout &lt;&lt; endl;   for_each(v1.begin(), v1.end(), print);   cout &lt;&lt; endl;   cout &lt;&lt; "第一个元素为: " &lt;&lt; v1.front() &lt;&lt; endl;   cout &lt;&lt; "最后一个元素为: " &lt;&lt; v1.back() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="互换容器"><a href="#互换容器" class="headerlink" title="互换容器:"></a>互换容器:</h3><p>swap(vec);//将vec与本身的元素互换</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;int&gt;v;for (int i = 0; i &lt; 100000; i++){v.push_back(i);}cout &lt;&lt; "v的容量为: " &lt;&lt; v.capacity() &lt;&lt; endl;cout &lt;&lt; "v的大小为: " &lt;&lt; v.size() &lt;&lt; endl;v.resize(3);cout &lt;&lt; "v的容量为: " &lt;&lt; v.capacity() &lt;&lt; endl;//容量未变cout &lt;&lt; "v的大小为: " &lt;&lt; v.size() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="巧用swap来收缩"><a href="#巧用swap来收缩" class="headerlink" title="巧用swap来收缩:"></a>巧用swap来收缩:</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt;v;for (int i = 0; i &lt; 100000; i++){    v.push_back(i);}cout &lt;&lt; "v的容量为: " &lt;&lt; v.capacity() &lt;&lt; endl;cout &lt;&lt; "v的大小为: " &lt;&lt; v.size() &lt;&lt; endl;v.resize(3);cout &lt;&lt; "v的容量为: " &lt;&lt; v.capacity() &lt;&lt; endl;//容量为变cout &lt;&lt; "v的大小为: " &lt;&lt; v.size() &lt;&lt; endl;//巧用swap来收缩vector&lt;int&gt;(v).swap(v);//!!!!!!//vector&lt;int&gt;(v)匿名对象//vector&lt;int&gt;x();调用拷贝构造函数，x不写就是匿名，拷贝一个v//此时会按照v的大小进行构造//所以x的大小和容量为3//x和v进行互换；//匿名对象结束自动释放,调用析构函数cout &lt;&lt; "v的容量为: " &lt;&lt; v.capacity() &lt;&lt; endl;cout &lt;&lt; "v的大小为: " &lt;&lt; v.size() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="预留空间"><a href="#预留空间" class="headerlink" title="预留空间:"></a>预留空间:</h3><p>减少vector在动态扩展容量时的扩展次数</p><p>只改变容量不申请内存</p><p>reserve()函数预分配出的空间没有被初始化,不可访问</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">vector&lt;int&gt;v1;//利用reserve预留空间v1.reserve(100000);int num = 0;//统计开辟的次数int* p = NULL;for (int i = 0; i &lt; 100000; i++){v1.push_back(i);if (p != &amp;v1[0]){p = &amp;v1[0];num++;}}cout &lt;&lt; "v1开辟的次数: " &lt;&lt; num &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>本质:</p><p>string是C++风格的字符串,而string本质上是一个类</p><h3 id="string和char-的区别"><a href="#string和char-的区别" class="headerlink" title="string和char*的区别:"></a>string和char*的区别:</h3><p>char*是一个指针</p><p>string是一个类,类内部封装了char*,管理这个字符串,是一个char*型的容器</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><p>string内部封装了很多成员方法</p><p>例如:查找find,拷贝copy,删除delete,替换replace,插入insert</p><p>string管理char*所分配的内存,不用担心复制越界和取值越界,由内部进行负责</p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数:"></a>构造函数:</h3><p>string();//创建一个空字符串 例如:string str;</p><p>string(const char*s);//使用字符串s初始化;</p><p>string(const string&amp;str);//使用一个string对象初始化另一个string对象;</p><p>string(int n,char c);//使用n个字符c初始化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s1;//默认构造string s2("aaa");//使用字符串初始化const char* str = "aaa";string s3(str);string s4(s3);//拷贝构造string s5(10, 'a');//十个acout &lt;&lt; s5 &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值操作-1"><a href="#赋值操作-1" class="headerlink" title="赋值操作:"></a>赋值操作:</h3><p>string&amp; operator=(const char* s);//char*类型字符串 赋值给当前字符串</p><p>string&amp; operator=(const string &amp;s);//把字符串s赋给当前字符串</p><p>string&amp; operator=(char c);//把字符赋值给当前字符串</p><p>string&amp; assign(const char *s);//把字符串s赋给当前的字符串</p><p>string&amp; assign(const char *s, int n);//把字符串s的前n个字符赋给当前的字符串</p><p>string&amp; assign(const string &amp;s);//把字符串s赋给当前字符串</p><p>string&amp; assign(int n, char c);//用n个字符c赋给当前字符串</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str1;str1 = "hello world";cout &lt;&lt; str1 &lt;&lt; endl;string str2;str2 = str1;cout &lt;&lt; str2 &lt;&lt; endl;string str3;str3 = 'a';cout &lt;&lt; str3 &lt;&lt; endl;string str4;str4.assign("hello C++");cout &lt;&lt; str4 &lt;&lt; endl;string str5;str5.assign("hello C++", 5);//前几个字符去赋值cout &lt;&lt; str5 &lt;&lt; endl;string str6;str6.assign(str5);cout &lt;&lt; str6 &lt;&lt; endl;string str7;str7.assign(10, 'w');cout &lt;&lt; str7 &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接:"></a>字符串拼接:</h3><p>string&amp; operator+=(const char c);//重载+=操作符</p><p>string&amp; operator+=(const string&amp; str);//重载+=操作符</p><p>string&amp; append(const char *s);//把字符串s连接到当前字符串结尾</p><p>string&amp; append(const char *s, int n);//把字符串s的前n个字符连接到当前字符串结尾</p><p>string&amp; append(const string &amp;s);//同operator+=(const string&amp; str)</p><p>string&amp; append(const string &amp;s, int pos, int n);//字符串s中从pos开始的n个字符连接到字符串结尾</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//字符串拼接string str1="我";str1 += "爱玩游戏";cout &lt;&lt; str1 &lt;&lt; endl;str1 += ';';cout &lt;&lt; str1 &lt;&lt; endl;string str2="LOL DNF";str1 += str2;cout &lt;&lt; str1 &lt;&lt; endl;string str3="I";str3.append("Love");cout &lt;&lt; str3 &lt;&lt; endl;str3.append("game abcde", 4);cout &lt;&lt; str3 &lt;&lt; endl;、<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换:"></a>查找和替换:</h3><p>int find(const string&amp; str, int pos=0)const;//查找str第一次出现位置,从pos开始查找</p><p>未找到返回 string::npos;</p><p>int find(const char* s, int pos=0)const;//查找s第一次出现位置,从pos开始查找</p><p>int find(const char* s, int pos, int n)const;//从pos位置查找s的前n个字符第一次位置</p><p>int find(const char c, int pos=0)const;查找字符c第一次出现的位置</p><p>int rfind(const string&amp; str, int pos=npos)const;//查找s最后一次出现位置,从pos开始查找</p><p>int rfind(const char* s, int pos=npos)const;//查找s最后一次出现的位置,从pos开始查找</p><p>int rfind(const char* s, int pos, int n)const;//从pos查找s的前n个字符最后一次位置</p><p>int rfind(const char c,int pos=0)const;//查找字符c最后一次位置</p><p>string&amp; replace(int pos, int n, const string&amp; str);//替换从pos开始n个字符为字符串str</p><p>string&amp; replace(int pos, int n, const char* s);//替换从pos开始的n个字符为字符串s</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str1="abcdefgde";int pos=str1.find("de");if (pos == string::npos){cout &lt;&lt; "未找到字符串" &lt;&lt;pos&lt;&lt; endl;}else{cout &lt;&lt; "找到字符串 pos=" &lt;&lt; pos &lt;&lt; endl;}//rfind和find的区别//rfind是从右往左查找 find从左往右查找//find第一次出现的位置//find最后一次出现的位置pos=str1.rfind("de");cout &lt;&lt; "pos=" &lt;&lt; pos &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str1 = "abcdefg";str1.replace(1, 3, "1111");//把bcd换成1111cout &lt;&lt; str1 &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较:"></a>字符串比较:</h3><p>=返回 0 &gt;返回1 &lt;返回-1</p><p>int compare(const string &amp;s)const;//与字符串s比较</p><p>int compare(const char *s)const;//与字符串s比较</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str1 = "aello";string str2 = "zello";if (str1.compare(str2) == 0){cout &lt;&lt; "str1等于str2" &lt;&lt; endl;}else if (str1.compare(str2) == 1){cout &lt;&lt; "str1大于str2" &lt;&lt; endl;}else{cout &lt;&lt; "str1小于str2" &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符存取"><a href="#字符存取" class="headerlink" title="字符存取:"></a>字符存取:</h3><p>char&amp; operator[] (int n);//通过[]方式取字符</p><p>char&amp; at(int n);//通过at方式获取字符串,会检查越界</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str = "hello";cout &lt;&lt; str &lt;&lt; endl;//1.通过[]for (int i = 0; i &lt; str.length(); i++){cout &lt;&lt; str[i];}cout &lt;&lt; endl;//2.通过atfor (int i = 0; i &lt; str.length(); i++){cout &lt;&lt; str.at(i) &lt;&lt; " "; //会检查下标}cout &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除-1"><a href="#插入和删除-1" class="headerlink" title="插入和删除:"></a>插入和删除:</h3><p>string&amp; insert(int pos, const char* s);//插入字符串</p><p>string&amp; insert(int pos, const string&amp; str);//插入字符串</p><p>string&amp; insert(int pos, int n, char c);//在指定位置插入n个字符c</p><p>string&amp; erase(int pos, int n=npos);//删除从pos开始的n个字符</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//字符串插入和删除string str = "hello";str.insert(1, "111");cout &lt;&lt; str &lt;&lt; endl;//删除str.erase(1, 3);//不填第二个参数就是从pos开始删完,包括poscout &lt;&lt; str &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="子串获取"><a href="#子串获取" class="headerlink" title="子串获取:"></a>子串获取:</h3><p>string substr(int pos=0, int n=npos)const;//返回由pos开始的n个字符组成的字符串</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string str = "abcdef";string substr = str.substr(1, 3);cout &lt;&lt; substr &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string emaill = "zhangshan@sina.com";string substr = emaill.substr(0, emaill.find('@'));//能刚好截到@前面,不包括@cout &lt;&lt; substr &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="set"><a href="#set" class="headerlink" title="set:"></a>set:</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h3><p>所有元素都会在插入时自动被排序</p><p>自动排序!</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质:"></a>本质:</h3><p>set/multiset属于关联式容器,底层结构是用二叉树实现</p><h3 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别:"></a>set和multiset区别:</h3><p>set不允许容器中有重复的元素</p><p>multiset允许容器中有重复的元素</p><p>包含set头文件就都可以用了</p><h3 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数:"></a>构造函数:</h3><p>set<t> st;//默认构造函数</t></p><p>set(const set &amp;st);//拷贝构造函数</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值:"></a>赋值:</h3><p>set&amp; operator=(const set &amp;st);//重载等号操作符</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const set&lt;int&gt;&amp; s){for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout&lt;&lt;*it&lt;&lt;" ";}cout&lt;&lt;endl;}void test01(){set&lt;int&gt;s1;//插入数据只有insert方式s1.insert(10);s1.insert(40);s1.insert(30);s1.insert(20);s1.insert(30);print(s1);//set容器特点:所有元素在插入时候自动被排序//set容器不允许插入重复值//拷贝构造set&lt;int&gt;s2(s1);print(s2);//赋值操作set&lt;int&gt;s3;s3 = s2;print(s3);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大小和交换"><a href="#大小和交换" class="headerlink" title="大小和交换:"></a>大小和交换:</h3><p>size();//返回容器中元素的数目</p><p>empty();//判断容器是否为空</p><p>swap(st);//交换两个set容器</p><p>不允许重新指定大小</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const set&lt;int&gt;&amp; s){for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){set&lt;int&gt;s1;//插入数据s1.insert(10);s1.insert(30);s1.insert(20);s1.insert(40);print(s1);//判断是否为空if (s1.empty()){cout &lt;&lt; "s1为空" &lt;&lt; endl;}else{cout &lt;&lt; "s1不为空" &lt;&lt; endl;cout &lt;&lt; "s1的大小为:" &lt;&lt; s1.size() &lt;&lt; endl;}set&lt;int&gt;s2;s2.insert(100);s2.insert(300);s2.insert(200);cout &lt;&lt; "s1  ";print(s1);cout &lt;&lt; "s2  ";print(s2);s1.swap(s2);cout &lt;&lt; "s1  ";print(s1);cout &lt;&lt; "s2  ";print(s2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除-2"><a href="#插入和删除-2" class="headerlink" title="插入和删除:"></a>插入和删除:</h3><p>insert(elem);//在容器中插入元素</p><p>clear();//清除所有元素</p><p>erase(pos);//删除pos迭代器所指的元素,返回下一个元素的迭代器</p><p>erase(elem);//删除容器中值为elem的元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const set&lt;int&gt;&amp; s){for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){set&lt;int&gt;s;//插入s.insert(20);s.insert(10);s.insert(30);s.insert(40);//遍历print(s);//删除set&lt;int&gt;::iterator it = s.begin();it++;s.erase(it);print(s);//重载版本s.erase(30);print(s);//清空s.clear();//s.erase(s.begin(), s.end());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找和统计"><a href="#查找和统计" class="headerlink" title="查找和统计:"></a>查找和统计:</h3><p>find(key);//查找key是否存在,若存在,返回该键的元素的迭代器;若不存在,返回set.end();</p><p>count(key);//统计key的元素个数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const set&lt;int&gt;&amp; s){for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void print(const multiset&lt;int&gt;&amp; s){for (multiset&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){set&lt;int&gt;s;s.insert(10);s.insert(30);s.insert(20);s.insert(50);print(s);multiset&lt;int&gt;s1;s1.insert(30);s1.insert(40);s1.insert(20);s1.insert(30);print(s1);set&lt;int&gt;::iterator it;//查找,返回值是迭代器it = s.find(60);if (it != s.end()){cout &lt;&lt; "找到元素" &lt;&lt; *it &lt;&lt; endl;}else{cout &lt;&lt; "未找到元素" &lt;&lt; endl;}//统计三十的个数int num = s.count(10);int num1 = s1.count(30);cout &lt;&lt; num &lt;&lt; endl;cout &lt;&lt; num1 &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="set和multiset的区别"><a href="#set和multiset的区别" class="headerlink" title="set和multiset的区别:"></a>set和multiset的区别:</h3><p>set不可以插入重复数据,而multiset可以</p><p>set插入数据的同时会返回插入结果,表示插入是否成功</p><p>multiset不会检测数据,因此可以插入重复数据</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const set&lt;int&gt;&amp; s){for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void print(const multiset&lt;int&gt;&amp; s){for (multiset&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){set&lt;int&gt;s1;multiset&lt;int&gt;s2;//pair 返回值//s1.insert(20);pair&lt;set&lt;int&gt;::iterator,bool&gt; ret=s1.insert(20);if (ret.second){cout &lt;&lt; "插入成功!" &lt;&lt; endl;}else{cout &lt;&lt; "插入失败" &lt;&lt; endl;}s1.insert(30);s1.insert(10);s1.insert(40);s2.insert(20);s2.insert(20);//multiset允许插入重复值//返回迭代器s2.insert(40);s2.insert(30);print(s1);print(s2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内置类型指定排序规则"><a href="#内置类型指定排序规则" class="headerlink" title="内置类型指定排序规则:"></a>内置类型指定排序规则:</h3><p>set容器默认排序规则为从小到大</p><p>利用仿函数,可以改变排序规则</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">class mycmp{public://仿函数bool operator()(const int v1, const int v2) const{return v1 &gt; v2;}};void print(const set&lt;int&gt;&amp; s){for (set&lt;int&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void print(const set&lt;int,mycmp&gt;&amp; s){for (set&lt;int,mycmp&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){set&lt;int&gt;s1;//必须要在插之前s1.insert(10);s1.insert(40);s1.insert(20);s1.insert(50);s1.insert(30);print(s1);//指定排序规则为从大到小set&lt;int,mycmp&gt;s2;//必须要在插之前s2.insert(10);s2.insert(40);s2.insert(20);s2.insert(50);s2.insert(30);print(s2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义类型指定排序规则"><a href="#自定义类型指定排序规则" class="headerlink" title="自定义类型指定排序规则:"></a>自定义类型指定排序规则:</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public:Person(string name, int age) :m_name(name), m_age(age){}string m_name;int m_age;};class cmp{public:bool operator()(const Person&amp; p1, const Person&amp; p2) const{return p1.m_age &gt; p2.m_age;}};void test(){//自定义数据类型指定排序规则set&lt;Person,cmp&gt;s;//创建person对象Person p1("刘备", 24);Person p2("关羽", 28);Person p3("张飞", 25);Person p4("赵云", 21);s.insert(p1);s.insert(p2);s.insert(p3);s.insert(p4);for (set&lt;Person,cmp&gt;::const_iterator it = s.begin(); it != s.end(); it++){cout &lt;&lt; (*it).m_name &lt;&lt; (*it).m_age &lt;&lt; endl;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map中所有元素都是pair</p><p>pair中第一个元素为key(键值),起到索引作用,第二个元素为value(实值)</p><p>所有元素都会根据元素的键值自动排序</p><p>map/multimap属于关联式容器,底层结构是用二叉树实现</p><p>可以根据key值快速找到value值</p><p>map和multimap的区别:</p><p>map不允许容器中有重复key值元素</p><p>multimap允许容器中有重复key值元素</p><h3 id="构造与赋值"><a href="#构造与赋值" class="headerlink" title="构造与赋值:"></a>构造与赋值:</h3><p>map&lt;T1,T2&gt;mp;//map默认构造函数</p><p>map(const map &amp;mp);//拷贝构造函数</p><p>map&amp; operator=(const map &amp;mp);//重载等号操作符</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const map&lt;int, int&gt;&amp; m){for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++){cout &lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;}}void test01(){map&lt;int, int&gt;m1;//按照key自动排序m1.insert(pair&lt;int, int&gt;(1, 10));m1.insert(pair&lt;int, int&gt;(3, 10));m1.insert(pair&lt;int, int&gt;(2, 10));m1.insert(pair&lt;int, int&gt;(4, 10));print(m1);map&lt;int, int&gt;m2(m1);print(m2);//赋值map&lt;int, int&gt;m3 = m2;print(m3);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大小和交换-1"><a href="#大小和交换-1" class="headerlink" title="大小和交换:"></a>大小和交换:</h3><p>size();//返回容器中元素的数目</p><p>empty();//判断容器是否为空</p><p>swap(st);//交换两个集合容器</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const map&lt;int, int&gt;&amp; m){for (map&lt;int, int&gt;::const_iterator it = m.begin(); it != m.end(); it++){cout &lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;}}void test01(){map&lt;int, int&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 10));m.insert(pair&lt;int, int&gt;(5, 10));m.insert(pair&lt;int, int&gt;(6, 10));if (m.empty()){cout &lt;&lt; "m为空" &lt;&lt; endl;}else{cout &lt;&lt; "m不为空" &lt;&lt; endl;cout &lt;&lt; "m的大小" &lt;&lt; m.size() &lt;&lt; endl;}}void test02(){map&lt;int, int&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 10));m.insert(pair&lt;int, int&gt;(5, 10));m.insert(pair&lt;int, int&gt;(6, 10));map&lt;int, int&gt;m2;m2.insert(pair&lt;int, int&gt;(20, 10));m2.insert(pair&lt;int, int&gt;(21, 10));m2.insert(pair&lt;int, int&gt;(50, 10));m2.insert(pair&lt;int, int&gt;(30, 10));m.swap(m2);print(m);print(m2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除-3"><a href="#插入和删除-3" class="headerlink" title="插入和删除:"></a>插入和删除:</h3><p>insert(elem);//在容器中插入元素</p><p>[]的重载;</p><p>clear();//清除所有元素</p><p>erase(pos);//删除pos迭代器所指的元素,返回下一个元素的迭代器</p><p>erase(beg,end);//删除区间[beg,end)的所有元素,返回下一个元素的迭代器</p><p>erase(key);//删除容器中值为key的元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//第一种map&lt;int, int&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 10));m.insert(pair&lt;int, int&gt;(5, 10));m.insert(pair&lt;int, int&gt;(6, 10));//第二种m.insert(make_pair(2, 20));//不用写模板参数//第三种m.insert(map&lt;int, int&gt;::value_type(3, 30));//第四种m[4] = 40;//不建议使用print(m);//cout &lt;&lt; m[7] &lt;&lt; endl;//会自动创建一个,key为7,value为0的数//主要用于通过key访问valuem.erase(m.begin());//删除print(m);m.erase(m.begin(), m.end());//区间删除m.clear();//清空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找和统计-1"><a href="#查找和统计-1" class="headerlink" title="查找和统计:"></a>查找和统计:</h3><p>find(key);//查找key是否存在,若存在,返回该键的元素的迭代器,若不存在,返回map.end();</p><p>count(key);//统计key的元素个数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&lt;int, int&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 10));m.insert(pair&lt;int, int&gt;(5, 10));m.insert(pair&lt;int, int&gt;(6, 10));map&lt;int, int&gt;m2;m2.insert(pair&lt;int, int&gt;(20, 10));m2.insert(pair&lt;int, int&gt;(21, 10));m2.insert(pair&lt;int, int&gt;(50, 10));m2.insert(pair&lt;int, int&gt;(30, 10));m.swap(m2);print(m);print(m2);cout &lt;&lt; (*m.find(20)).first &lt;&lt; " " &lt;&lt; (*m.find(20)).second &lt;&lt; endl;cout &lt;&lt; m.count(20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h3><p>利用仿函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class cmp{public:bool operator()(int v1, int v2)const{return v1 &gt; v2;}};void print(const map&lt;int, int,cmp&gt;&amp; m){for (map&lt;int, int,cmp&gt;::const_iterator it = m.begin(); it != m.end(); it++){cout &lt;&lt; (*it).first &lt;&lt; " " &lt;&lt; (*it).second &lt;&lt; endl;}}void test01(){//第一种map&lt;int, int,cmp&gt;m;m.insert(pair&lt;int, int&gt;(1, 10));m.insert(pair&lt;int, int&gt;(2, 10));m.insert(pair&lt;int, int&gt;(5, 10));m.insert(pair&lt;int, int&gt;(6, 10));//第二种m.insert(make_pair(2, 20));//不用写模板参数//第三种m.insert(map&lt;int, int&gt;::value_type(3, 30));//第四种//m[4] = 40;//不建议使用print(m);//cout &lt;&lt; m[7] &lt;&lt; endl;//会自动创建一个,key为7,value为0的数//主要用于通过key访问valuem.erase(m.begin());//删除//print(m);//m.erase(m.begin(), m.end());//区间删除//m.clear();//清空}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>成对出现的数据,利用对组可以返回两个数据</p><p>不用包含头文件</p><p>两种创建方式</p><p>pair&lt;type,type&gt;p(value1,value2);</p><p>pair&lt;type,type&gt;p=make_pair(value1,value2);</p><p>pair&lt;type,type&gt;p=p{value1,value2};//cpp17</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void test01(){//第一种方式pair&lt;string, int&gt;p("Tom", 20);cout &lt;&lt; "姓名: " &lt;&lt; p.first &lt;&lt; "  年龄: " &lt;&lt; p.second &lt;&lt; endl;//第二种方式pair&lt;string, int&gt;p1 = make_pair("Jerry", 30);cout &lt;&lt; "姓名: " &lt;&lt; p1.first &lt;&lt; "  年龄: " &lt;&lt; p1.second &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p>queue容器是一种先进先出的数据结构,它有两个出口</p><h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口:"></a>常用接口:</h3><h4 id="构造函数-3"><a href="#构造函数-3" class="headerlink" title="构造函数:"></a>构造函数:</h4><p>queue<t> que;//queue采用模板类实现,queue对象的默认构造形式</t></p><p>queue(const queue &amp;que);//拷贝构造函数</p><h4 id="赋值操作-2"><a href="#赋值操作-2" class="headerlink" title="赋值操作:"></a>赋值操作:</h4><p>queue&amp; operator=(const queue &amp;que);//重载等号操作符</p><h4 id="数据存取-1"><a href="#数据存取-1" class="headerlink" title="数据存取:"></a>数据存取:</h4><p>push(elem);//往队尾添加元素</p><p>pop();//从队头移除第一个元素</p><p>back();//返回最后一个元素</p><p>front();//返回第一个元素</p><h4 id="大小操作"><a href="#大小操作" class="headerlink" title="大小操作:"></a>大小操作:</h4><p>empty();//判断队列是否为空</p><p>size();//返回队列的大小</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public:Person(string name, int age) :m_name(name),m_age(age){}string m_name;int m_age;};void test01(){//queue是一种先进先出的数据结构,有两个出口//queue不允许有遍历行为queue&lt;Person&gt;q,q1;//入队push 出队pop//队头front 队尾back//只能看到队头队尾//empty sizeq.push(Person("唐僧",30));q.push(Person("孙悟空",1000));q.push(Person("猪八戒",900));q.push(Person("沙僧",800));q1 = q;cout &lt;&lt; "q1的大小: " &lt;&lt; q1.size() &lt;&lt; endl;cout &lt;&lt; "q1的队尾: " &lt;&lt; q1.back().m_name &lt;&lt; " " &lt;&lt; q1.back().m_age &lt;&lt; endl;cout &lt;&lt; "q1的队头: " &lt;&lt; q1.front().m_name &lt;&lt; " " &lt;&lt; q1.front().m_age &lt;&lt; endl;//出队q1.pop();cout &lt;&lt; "q1的队头: " &lt;&lt; q1.front().m_name &lt;&lt; " " &lt;&lt; q1.front().m_age &lt;&lt; endl;cout &lt;&lt; "q1的大小: " &lt;&lt; q1.size() &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><ul><li><p>priority_queue：优先队列，数据预设<strong>由大到小</strong>排序，即优先权高的数据会先被取出。</p></li><li><p>定义：</p><ul><li>priority_queue<int>pq;</int></li></ul></li><li><p>把元素x 加进priority_queue：</p><ul><li>pq.push(x)；</li></ul></li><li><p>读取优先权最高的值：</p><ul><li>x = pq.top(）;</li><li>pq.pop(); // 读取后删除</li></ul></li><li><p>判断是否为空的priority_queue：</p><ul><li>pq.empty() 返回true代表为空</li><li>pq.size() 返回元素个数</li></ul></li><li><p>如需改变priority_queue的优先权定义：</p><ul><li>priority_queue<t> pq; 预设由大排到小</t></li><li>priority_queue&lt;T, vector<t>, greater<t> &gt; pq; 改成由小排到大</t></t></li><li>priority_queue&lt;T, vector <t>, cmp &gt; pq; 自行定义cmp 排序</t></li></ul></li><li><p>自行定义cmp，使用struct：</p><ul><li><p>重载运算符() 即仿函数</p></li><li><p>注意：因为优先判定为**!cmp<strong>，所以「由大排到小」需「</strong>反向**」定义实现「最小值优先」。反之亦然。</p></li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Compare</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> Type a<span class="token punctuation">,</span><span class="token keyword">const</span> Type b<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>        <span class="token comment">//自定义排序规则</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p>stack容器是一种先进后出的数据结构,他只有一个出口</p><p>栈中只有顶端的元素才可以被外界使用,因此栈不允许有遍历行为</p><h3 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口:"></a>常用接口:</h3><h4 id="构造函数-4"><a href="#构造函数-4" class="headerlink" title="构造函数:"></a>构造函数:</h4><p>stack<t>stk;//stack采用模板类实现,stack对象的默认构造形式</t></p><p>stack(const stack &amp;stk);//拷贝构造函数</p><h4 id="赋值操作-3"><a href="#赋值操作-3" class="headerlink" title="赋值操作:"></a>赋值操作:</h4><p>stack&amp; operator=(const stack &amp;stk);//重载等号操作符</p><h4 id="数据存取-2"><a href="#数据存取-2" class="headerlink" title="数据存取:"></a>数据存取:</h4><p>push(elem);//向栈顶添加元素</p><p>pop();//从栈顶移除第一个元素</p><p>top();//返回栈顶元素</p><h4 id="大小操作-1"><a href="#大小操作-1" class="headerlink" title="大小操作:"></a>大小操作:</h4><p>empty();//判断堆栈是否为空</p><p>size();//返回栈的大小</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//栈不允许有遍历行为//栈可以判断是否为空 empty//栈可以返回元素个数 size 是在入栈的时候统计的//构造只有默认构造和拷贝构造void test01(){stack&lt;int&gt; s;//特点：先进后出的数据结构//入栈操作s.push(10);s.push(20);cout &lt;&lt; "s的大小: " &lt;&lt; s.size() &lt;&lt; endl;//只要栈不为空就，查看栈顶，并且执行出栈操作while (!s.empty()){cout &lt;&lt; s.top() &lt;&lt; " ";s.pop();}cout &lt;&lt; endl;cout &lt;&lt; "s的大小: " &lt;&lt; s.size();s.push(10);s.push(20);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念:"></a>基本概念:</h3><p>功能:双端数组,可以对头端进行插入删除操作</p><h3 id="deque和vector的区别"><a href="#deque和vector的区别" class="headerlink" title="deque和vector的区别:"></a>deque和vector的区别:</h3><p>vector对于头部的插入和删除效率低,数据量越大效率越低</p><p>deque相对而言,对头部的插入删除速度会比vector快</p><p>vector访问元素时的速度会比deque快,这和两者内部实现有关</p><h3 id="deque内部工作原理"><a href="#deque内部工作原理" class="headerlink" title="deque内部工作原理:"></a>deque内部工作原理:</h3><p>deque内部有个中控器,维护每段缓冲区中的内容,缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址,使得使用deque时像一片连续的内存空间</p><h3 id="赋值操作-4"><a href="#赋值操作-4" class="headerlink" title="赋值操作:"></a>赋值操作:</h3><p>deque&amp; operator=(const deque &amp;deq);//重载等号操作符</p><p>assign(beg,end);//将[beg，end)区间中的数据拷贝赋值给本身,左闭右开</p><p>assign(n,elem);//将n个elem拷贝赋值给本身</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   void print(const deque&lt;int&gt;&amp; d)   {       for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)       {           cout &lt;&lt; *it &lt;&lt; " ";       }       cout &lt;&lt; endl;}deque&lt;int&gt;d1;for (int i = 0; i &lt; 10; i++){d1.push_back(i);}print(d1);//等号赋值deque&lt;int&gt;d2;d2 = d1;print(d2);//assign赋值deque&lt;int&gt;d3;d3.assign(d1.begin(), d1.end());print(d3);deque&lt;int&gt;d4;d4.assign(10, 100);print(d4);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大小操作-2"><a href="#大小操作-2" class="headerlink" title="大小操作:"></a>大小操作:</h3><p>deque.empty();//判断容器是否为空</p><p>deque.size();//返回容器中元素的个数</p><p>deque.resize(num);//重新指定容器的长度为num,若容器变长,则以默认值填充新位置</p><p>//如果容器变短,则末尾超出容器长度部分的元素被删除</p><p>deque.resize(num,elem);//重新指定容器的长度为num,若容器变长,则以elem值填充新位置</p><p>//如果容器变短,则末尾超出容器长度部分的元素被删除</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">   void print(const deque&lt;int&gt;&amp; d)   {       for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++)       {           cout &lt;&lt; *it &lt;&lt; " ";       }       cout &lt;&lt; endl;   }deque&lt;int&gt;d1;for (int i = 0; i &lt; 10; i++){d1.push_back(i);}print(d1);//deque没有容量,只有元素个数cout &lt;&lt; "deque的大小" &lt;&lt; d1.size() &lt;&lt; endl;cout &lt;&lt; "deque是否为空" &lt;&lt; d1.empty() &lt;&lt; endl;//deque重新指定大小d1.resize(5);print(d1);//第二个参数为如果空间变大填入的数d1.resize(10, 100);print(d1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除-4"><a href="#插入和删除-4" class="headerlink" title="插入和删除:"></a>插入和删除:</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const deque&lt;int&gt;&amp; d){for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>push_back(elem);//在容器尾部添加一个数据</p><p>push_front(elem);//在容器头部插入一个数据</p><p>pop_back();//删除容器最后一个数据</p><p>pop_front();//删除容器第一个数据</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">deque&lt;int&gt;d1;//尾插d1.push_back(10);d1.push_back(100);//头插d1.push_front(200);d1.push_front(20);print(d1);//尾删d1.pop_back();print(d1);//头删d1.pop_front();print(d1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>insert(pos,elem);//在pos位置插入一个elem元素的拷贝,返回新数据的位置</p><p>insert(pos,n,elem);//在pos位置插入n个elem数据,无返回值</p><p>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据,无返回值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">deque&lt;int&gt;d1,d2;d2.push_back(1);d2.push_back(2);d2.push_back(3);d1.push_back(10);d1.push_back(20);d1.push_front(100);d1.push_front(200);print(d1);//insert插入d1.insert(d1.begin() + 1, 2000);print(d1);d1.insert(d1.begin(), 2, 10000);//两个一万print(d1);d1.insert(d1.begin(), d2.begin(), d2.end());//在头部插一个区间print(d1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>clear();//清空容器的所有数据</p><p>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置</p><p>erase(pos);//删除pos位置的数据,返回下一个数据的位置</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//deque删除deque&lt;int&gt;d1;d1.push_back(10);d1.push_back(20);d1.push_front(100);d1.push_front(200);print(d1);d1.erase(d1.begin()+1);print(d1);d1.erase(d1.begin() + 1, d1.end());//左闭右开区间删除print(d1);d1.clear();if (d1.empty() == true){cout &lt;&lt; "d1为空" &lt;&lt; endl;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据存取-3"><a href="#数据存取-3" class="headerlink" title="数据存取:"></a>数据存取:</h3><p>at(int idx);//返回索引idx所指的数据</p><p>operator[];//返回索引idx所指的数据</p><p>front();//返回容器中第一个数据元素</p><p>back();//返回容器中最后一个元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const deque&lt;int&gt;&amp; d){for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}deque&lt;int&gt;d1;d1.push_back(10);d1.push_back(100);d1.push_back(20);d1.push_back(30);d1.push_front(100);d1.push_front(200);for (int i = 0; i &lt; d1.size(); i++){//通过中括号方式cout &lt;&lt; d1[i] &lt;&lt; " ";}cout &lt;&lt; endl;//通过at的方式for (int i = 0; i &lt; d1.size(); i++){cout &lt;&lt; d1.at(i) &lt;&lt; " ";}cout &lt;&lt; endl;cout &lt;&lt; "第一个元素为: " &lt;&lt; d1.front() &lt;&lt; endl;cout &lt;&lt; "最后一个元素为: " &lt;&lt; d1.back() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作:"></a>排序操作:</h3><p>sort(iterator beg,iterator end);//对beg和end区间内元素进行排序</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const deque&lt;int&gt;&amp; d){for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){deque&lt;int&gt;d1;d1.push_back(100);d1.push_back(1000);d1.push_back(20);print(d1);sort(d1.begin(), d1.end());//随机访问迭代器均支持sort排序print(d1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念:"></a>基本概念:</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能:"></a>功能:</h4><p>将数组进行链式存储</p><h4 id="链表-list"><a href="#链表-list" class="headerlink" title="链表:(list)"></a>链表:(list)</h4><p>是一种物理存储单元上非连续的存储结构,数据元素的逻辑顺序是通过链表中的指针链接实现的</p><h4 id="链表的组成"><a href="#链表的组成" class="headerlink" title="链表的组成:"></a>链表的组成:</h4><p>链表由一系列结点组成</p><h4 id="结点的组成"><a href="#结点的组成" class="headerlink" title="结点的组成:"></a>结点的组成:</h4><p>一个是存储数据元素的数据域,另一个是存储下一个结点地址的指针域</p><p>STL中的链表是一个双向循环链表</p><h3 id="构造函数-5"><a href="#构造函数-5" class="headerlink" title="构造函数:"></a>构造函数:</h3><p>list<t>list;//list采用模板类实现,对象的默认构造形式</t></p><p>list(beg,end);//构造函数将区间[beg,end)区间中的元素拷贝给本身,左闭右开</p><p>list(n,elem);//构造函数将n个elem拷贝给本身</p><p>list(const list &amp;lst);//拷贝构造函数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const list&lt;int&gt;&amp; L){for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){list&lt;int&gt;L1;//默认构造L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);print(L1);list&lt;int&gt;L2(L1);//拷贝构造print(L2);list&lt;int&gt;L3(L1.begin(), L1.end());//区间构造print(L3);list&lt;int&gt;L4(10, 1000);//n个elemprint(L4);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值和交换"><a href="#赋值和交换" class="headerlink" title="赋值和交换:"></a>赋值和交换:</h3><p>assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身</p><p>assign(n,elem);//将n个elem拷贝赋值给本身</p><p>list&amp; operator=(const list &amp;list);//重载等号操作符</p><p>swap(lst);//将lst与本身的元素互换</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const list&lt;int&gt;&amp; L){for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);print(L1);list&lt;int&gt;L2 = L1;//=赋值print(L2);list&lt;int&gt;L3;L3.assign(L2.begin(), L2.end());//区间赋值print(L3);list&lt;int&gt;L4;L4.assign(10, 100);//n个elemprint(L4);}void test02(){list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);list&lt;int&gt;L2;L2.assign(10, 100);print(L1);print(L2);L1.swap(L2);print(L1);print(L2);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="容量和大小-1"><a href="#容量和大小-1" class="headerlink" title="容量和大小:"></a>容量和大小:</h3><p>empty();//判断容器是否为空</p><p>size();//返回容器中元素的个数</p><p>resize(int num);//重新指定容器的长度为num,若容器变长,则以默认值填充新位置</p><p>//如果容器变短,则末尾超出容器长度的元素被删除</p><p>resize(int num,elem);//重新指定容器的长度为num,若容器变长,则以elem值填充新位置</p><p>//如果容器变短,则末尾超出容器长度的元素被删除</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const list&lt;int&gt;&amp; L){for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){//大小操作list&lt;int&gt;L1;L1.push_back(10);L1.push_back(20);L1.push_back(30);L1.push_back(40);print(L1);if (L1.empty()){cout &lt;&lt; "L1为空!" &lt;&lt; endl;}else{cout &lt;&lt; "L1不为空!" &lt;&lt; endl;cout &lt;&lt; "L1的元素个数为: " &lt;&lt; L1.size() &lt;&lt; endl;}L1.resize(10, 10000);print(L1);L1.resize(2);print(L1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入和删除-5"><a href="#插入和删除-5" class="headerlink" title="插入和删除:"></a>插入和删除:</h3><p>push_back(elem);//在容器尾部加入一个元素</p><p>pop_back();//删除容器中最后一个元素</p><p>push_from(elem);//在容器开头插入一个元素</p><p>insert(pos,elem);//在pos位置插elem元素的拷贝,返回新数据的位置</p><p>insert(pos,n,elem);//在pos位置插入n个elem数据,无返回值</p><p>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据,返回下一个数据的位置,左闭右开</p><p>clear();//移除容器的所有数据</p><p>erase(beg,end);//删除[beg,end)区间的数据,返回下一个数据的位置</p><p>erase(pos);//删除pos位置的数据,返回下一个数据的位置</p><p>remove(elem);//删除容器中所有与elem值匹配的元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const list&lt;int&gt;&amp; L){for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}void test01(){list&lt;int&gt;L;//尾插L.push_back(10);L.push_back(20);L.push_back(30);//头插L.push_front(100);L.push_front(200);L.push_front(300);print(L);//尾删L.pop_back();print(L);//头删L.pop_front();print(L);//insert插入list&lt;int&gt;::iterator it = L.begin();it++;L.insert(it, 1000);print(L);it = L.begin();//erase删除L.erase(it++);print(L);//移除L.push_back(10000);print(L);L.remove(10000);print(L);//清空L.clear();print(L);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据存取-4"><a href="#数据存取-4" class="headerlink" title="数据存取:"></a>数据存取:</h3><p>front();//返回第一个元素</p><p>back();//返回最后一个元素</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void test01(){list&lt;int&gt;L;L.push_back(10);L.push_back(20);L.push_back(30);L.push_back(40);for (list&lt;int&gt;::iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;cout &lt;&lt; "L第一个元素: " &lt;&lt; L.front() &lt;&lt; endl;cout &lt;&lt; "L最后一个元素: " &lt;&lt; L.back() &lt;&lt; endl;}//list&lt;int&gt;::iterator it=L.begin();//it++;it--;支持双向//it=it+1;//不报错就支持随机访问，在list里面这种写法报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="反转和排序"><a href="#反转和排序" class="headerlink" title="反转和排序:"></a>反转和排序:</h3><p>reverse();//反转链表</p><p>sort();//链表排序</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const list&lt;int&gt;&amp; L){for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;}bool cmp(int a1,int a2){//降序,第一个数 &gt; 第二个数return a1 &gt; a2;}void test01(){list&lt;int&gt;L1;L1.push_back(20);L1.push_back(10);L1.push_back(50);L1.push_back(40);L1.push_back(30);print(L1);//反转后L1.reverse();print(L1);//排序//所有不支持随机访问迭代器的容器,不可以用标准算法//不支持随机访问迭代器的容器,内部会提供对应的一些算法L1.sort();//从小到大print(L1);L1.sort(cmp);//从大到小 , 用reverse会浪费效率print(L1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序案例"><a href="#排序案例" class="headerlink" title="排序案例:"></a>排序案例:</h3><p>案例描述:将Person自定义数据类型进行排序,Person中属性有姓名,年龄,身高</p><p>排序规则:按照年龄进行升序,如果年龄相同按照身高进行降序</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Person{public:Person(string name, int age, int height) :m_name(name),m_age(age),m_height(height){}string m_name;int m_age;int m_height;};void print(const list&lt;Person&gt;&amp; L){for (list&lt;Person&gt;::const_iterator it = L.begin(); it != L.end(); it++){cout &lt;&lt; (*it).m_name &lt;&lt; " " &lt;&lt; (*it).m_age &lt;&lt; " " &lt;&lt; (*it).m_height &lt;&lt; endl;}}bool cmp(Person p1, Person p2){if (p1.m_age == p2.m_age){return p1.m_height &gt; p2.m_height;}return p1.m_age &lt; p2.m_age;}void test01(){list&lt;Person&gt;L;Person p1("刘备", 35, 175);Person p2("曹操", 45, 180);Person p3("孙权", 40, 170);Person p4("赵云", 25, 190);Person p5("张飞", 35, 160);Person p6("关羽", 35, 200);L.push_back(p1);L.push_back(p2);L.push_back(p3);L.push_back(p4);L.push_back(p5);L.push_back(p6);L.sort(cmp);print(L);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>[^2]: </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu</title>
      <link href="/2023/12/10/ubuntu/"/>
      <url>/2023/12/10/ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="开机遇到grub"><a href="#开机遇到grub" class="headerlink" title="开机遇到grub>"></a>开机遇到grub&gt;</h2><h3 id="双系统开机到grub的解决"><a href="#双系统开机到grub的解决" class="headerlink" title="双系统开机到grub的解决"></a>双系统开机到grub的解决</h3><ol><li><p>先在grub&gt;输入ls，展示的是所有分区</p></li><li><p>然后再ls (xxx,xxx)/boot/grub注意括号里面的应该填上自己分区名字，这一步是为了检查grub所在的具体分区，如果没有出现没有找到文件位置的提示，就说明找对了</p></li><li><p>假如找到的分区为(hd1,gpt3)那么就运行set root=(hd1,gpt3)</p></li><li><p>再输入set prefix=(hd1,gpt3)/boot/grub</p></li><li><p>输入insmod normal，再输入normal</p></li><li><p>就会到正常引导了</p></li><li><p>进入linux系统后sudo update-grub再输入sudo grub-install /dev/sda</p></li></ol><p>PS:出现这种情况的可能原因：win系统更新覆盖了，强制关闭linux，等等</p><h2 id="Linux安装MySQL"><a href="#Linux安装MySQL" class="headerlink" title="Linux安装MySQL"></a>Linux安装MySQL</h2><h3 id="Linux-UNIX-上安装-MySQL"><a href="#Linux-UNIX-上安装-MySQL" class="headerlink" title="Linux/UNIX 上安装 MySQL"></a>Linux/UNIX 上安装 MySQL</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> mysql-server <span class="token comment">#默认最新版</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装依赖</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libmysqlclient-dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">netstat</span> <span class="token parameter variable">-tap</span> <span class="token operator">|</span> <span class="token function">grep</span> mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当你在Ubuntu上使用sudo apt-get install mysql-server指令安装mysql后，你会发现你登录不上，会出现这样的情况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hadoop@yjp:~$ mysqlERROR <span class="token number">1045</span> <span class="token punctuation">(</span><span class="token number">28000</span><span class="token punctuation">)</span>: Access denied <span class="token keyword">for</span> user <span class="token string">'yjp'</span>@<span class="token string">'localhost'</span> <span class="token punctuation">(</span>using password: NO<span class="token punctuation">)</span>hadoop@yjp:~$ mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span>Enter password: ERROR <span class="token number">1698</span> <span class="token punctuation">(</span><span class="token number">28000</span><span class="token punctuation">)</span>: Access denied <span class="token keyword">for</span> user <span class="token string">'root'</span>@<span class="token string">'localhost'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用上述指令安装mysql后，在安装过程中mysql数据库自动为你设置了账号密码，并放在了/etc/mysql/debian.cnf文件中</p><h3 id="修改MYSQL-用户密码"><a href="#修改MYSQL-用户密码" class="headerlink" title="修改MYSQL 用户密码"></a>修改MYSQL 用户密码</h3><p>一、切换数据库</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">use mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>二、修改root用户密码</p><p>注意下面两条修改mysql root用户密码的命令只适用于mysql5.7版本及以下</p><p>这里你会发现你在网上搜出来的大部分修改面的命令都是</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">update user set password=PASSWORD("123456") where user=root;                              --设置密码为123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者是</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">update user set authentication_string=PASSWORD(“123456”) where user=‘root’;              --设置密码为123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你是mysql5.7用户及以下，上面两条指令适用于你！</p><p>执行完命令之后 flush privileges;  更新所有操作权限，重启数据库 service mysql restart 即可</p><p>mysql 5.7.9以后废弃了password字段和password()函数；authentication_string:字段表示用户密码，而authentication_string字段下只能是mysql加密后的41位字符串密码。</p><p>而我们一般现在使用指令安装mysql会默认安装最新版mysql8.0</p><p>修改mysql8.0 root用户密码正确打开方式</p><p>MySql 从8.0开始修改密码有了变化，在user表加了字段authentication_string，修改密码前先检查authentication_string是否为空</p><p>如果不为空，先置空字段在修改密码</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">use mysql; update user set authentication_string='' where user='root';      --将字段置为空alter user 'root'@'localhost' identified with mysql_native_password by '123456';   --修改密码为123456如果为空，则直接修改密码alter user 'root'@'localhost' identified with mysql_native_password by '123456';   --修改密码为123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改成功！</p><img src="/2023/12/10/ubuntu/mysql-changepasswd.png" class="" title="MySQL修改根用户密码"><p><strong>如果出现下列错误：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是由于你上面如果用的第二种方法设置绕过密码登录，这时root用户是无密码状态，会报这个错误！</p><p>这时，先执行</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再执行修改密码命令就行了</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">alter user 'root'@'localhost' identified with mysql_native_password by '123456';      --修改密码为123456<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>大功告成！</p><p>重启mysql</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> mysql restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用第一种方法直接查看mysql默认账户密码登录的则自动忽略下述内容！</p><p>如果你是修改的 /etc/mysql/mysql.conf.d/mysqld.cnf  文件设置绕过密码登录（即上述第二种方法进入数据库）</p><p>设置密码完毕后一定要将 skip-grant-tables 这句代码在文件中注释掉。</p><p>然后重启mysql</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">service</span> mysql restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>当然你也可以先登录电脑root用户，初始mysql的root用户没有密码，只有通过root用户登录mysql时直接回车可以跳过输入密码阶段。</li></ul><h3 id="MYSQL无法读取本地文件文件"><a href="#MYSQL无法读取本地文件文件" class="headerlink" title="MYSQL无法读取本地文件文件"></a>MYSQL无法读取本地文件文件</h3><h4 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h4><p>如果你的系统启用了 SELinux 或 AppArmor，这些安全模块可能会影响文件访问权限。你可以通过禁用它们或者配置相应的规则来解决问题。</p><p>在使用 Ubuntu 或类似基于 Debian 的 Linux 发行版时，AppArmor 是一种应用程序安全框架，用于限制特定程序的活动。如果你需要禁用 AppArmor，可以按照以下步骤进行操作：</p><h4 id="修改AppArmor配置文件"><a href="#修改AppArmor配置文件" class="headerlink" title="修改AppArmor配置文件"></a>修改AppArmor配置文件</h4><p>MySQL的AppArmor的配置文件是/etc/apparmor.d/usr.sbin.mysqld，其中usr.sbin.mysqld代表执行程序/usr/sbin/mysqld，也就是MySQL服务的主程序</p><img src="/2023/12/10/ubuntu/AppArmor-config.png" class="" title="AppArmor关于mysql的安全配置信息"><p>第一行加入允许读取的数据文件夹</p><p>rwk表示</p><ul><li><p>r - 读取 - 读取数据的权限</p></li><li><p>w - 写入 - 创建、删除、写入文件和扩展文件的权限</p></li><li><p>k - lock - 锁定文件的权限，与 write perm 结合以确定它是否有权获取独占锁定</p></li></ul><p>重启AppArmor</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> apparmor reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="取消禁用AppArmor服务-不推荐"><a href="#取消禁用AppArmor服务-不推荐" class="headerlink" title="取消禁用AppArmor服务(不推荐)"></a>取消禁用AppArmor服务(不推荐)</h4><h5 id="1-启用-AppArmor-服务："><a href="#1-启用-AppArmor-服务：" class="headerlink" title="1. 启用 AppArmor 服务："></a>1. 启用 AppArmor 服务：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl <span class="token builtin class-name">enable</span> apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这将使 AppArmor 在系统启动时自动启动。</p><h5 id="2-启动-AppArmor-服务："><a href="#2-启动-AppArmor-服务：" class="headerlink" title="2. 启动 AppArmor 服务："></a>2. 启动 AppArmor 服务：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl start apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-检查-AppArmor-状态："><a href="#3-检查-AppArmor-状态：" class="headerlink" title="3. 检查 AppArmor 状态："></a>3. 检查 AppArmor 状态：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl status apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上述命令将显示 AppArmor 服务的当前状态。如果状态显示为 “active”，则表示 AppArmor 服务已成功启动。</p><h5 id="4-重新加载-AppArmor-配置（可选）："><a href="#4-重新加载-AppArmor-配置（可选）：" class="headerlink" title="4. 重新加载 AppArmor 配置（可选）："></a>4. 重新加载 AppArmor 配置（可选）：</h5><p>在重新启用 AppArmor 后，你可以选择重新加载配置以使更改生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> apparmor reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，如果你使用的是 systemd：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl reload apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这些步骤应该使 AppArmor 服务重新启用并运行。请注意，重新启用 AppArmor 服务可能会导致之前由 AppArmor 禁用的应用程序再次受到 AppArmor 的限制。确保你的应用程序配置适当，以适应 AppArmor 的规则。</p><h4 id="禁用-AppArmor-服务-不推荐-："><a href="#禁用-AppArmor-服务-不推荐-：" class="headerlink" title="禁用 AppArmor 服务(不推荐)："></a>禁用 AppArmor 服务(不推荐)：</h4><h5 id="1-停止-AppArmor-服务："><a href="#1-停止-AppArmor-服务：" class="headerlink" title="1. 停止 AppArmor 服务："></a>1. 停止 AppArmor 服务：</h5>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl stop apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-禁用-AppArmor-服务（可选）"><a href="#2-禁用-AppArmor-服务（可选）" class="headerlink" title="2. 禁用 AppArmor 服务（可选）:"></a>2. 禁用 AppArmor 服务（可选）:</h5>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> systemctl disable apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   这样系统启动时就不会加载 AppArmor 服务。</p><h5 id="3-重启计算机："><a href="#3-重启计算机：" class="headerlink" title="3. 重启计算机："></a>3. 重启计算机：</h5>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="卸载-AppArmor-软件包-不推荐-："><a href="#卸载-AppArmor-软件包-不推荐-：" class="headerlink" title="卸载 AppArmor 软件包(不推荐)："></a>卸载 AppArmor 软件包(不推荐)：</h4><p>如果你希望彻底删除 AppArmor，而不仅仅是停止服务，可以执行以下步骤：</p><h5 id="1-卸载-AppArmor-软件包："><a href="#1-卸载-AppArmor-软件包：" class="headerlink" title="1. 卸载 AppArmor 软件包："></a>1. 卸载 AppArmor 软件包：</h5>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> purge apparmor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   这将删除 AppArmor 软件包及其配置文件。</p><h5 id="2-重启计算机："><a href="#2-重启计算机：" class="headerlink" title="2. 重启计算机："></a>2. 重启计算机：</h5>   <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">reboot</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请注意，禁用或删除 AppArmor 可能会导致系统安全性降低，因为 AppArmor 的目的是提供一层额外的安全保护。在禁用或删除之前，请确保你理解了相关的风险，并确保你有其他安全机制来保护系统。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li>[1] <a href="https://zhuanlan.zhihu.com/p/407785086">AppArmor与MySQL</a></li></ul><h3 id="MySQL的读取"><a href="#MySQL的读取" class="headerlink" title="MySQL的读取"></a>MySQL的读取</h3><p>mysql的位置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">which</span> mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/bin/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 mysql 配置文件加载顺序</span>/usr/bin/mysql <span class="token parameter variable">--verbose</span> <span class="token parameter variable">--help</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-A</span> <span class="token number">1</span> <span class="token string">'Default options'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后会出现一些信息</p><img src="/2023/12/10/ubuntu/MySQL-config.png" class="" title="MySQL配置加载顺序"><p>这个信息的意思是：</p><p>服务器首先读取的是 /etc/my.cnf 文件，如果前一个文件不存在则继续读 /etc/mysql/my.cnf 文件，依此类推，如若还不存在便会去读~/.my.cnf文件。</p><p>如果以上文件都不存在，则说明在对mysql编译完成之后你没有对mysql进行配置，需要你自己复制一份mysql提供的默认配置文件到上面提到的目录中，然后改名为my.cnf，修改文件的所有者和所属组并赋予执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> /usr/etc<span class="token function">cp</span> /usr/support-files/my-default.cnf /usr/local/mysql/etc/my.cnf<span class="token function">chown</span> <span class="token parameter variable">-R</span> mysql:mysql /usr/etc/<span class="token function">chmod</span> <span class="token number">755</span> /usr/etc/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成以上操作之后，需要对my.cnf进行基本配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /usr/etc/my.cnf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">basedir <span class="token operator">=</span> /usr/local/mysql              <span class="token comment"># 指mysql的安装目录</span>datadir <span class="token operator">=</span> /usr/local/mysql/data         <span class="token comment"># 指mysql的数据存放目录</span>port <span class="token operator">=</span> <span class="token number">3306</span>                             <span class="token comment"># 指mysql的监听端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>最后重启mysql使配置生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/support-files/mysql.server restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果修改my.cnf后mysql启动不了,可以通过如下方式查看错误信息</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/bin/mysqld <span class="token parameter variable">--verbose</span> <span class="token parameter variable">--help</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-A</span> <span class="token number">1</span> <span class="token string">'Default options'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改mysql配置文件"><a href="#修改mysql配置文件" class="headerlink" title="修改mysql配置文件"></a>修改mysql配置文件</h4><img src="/2023/12/10/ubuntu/MySQL-secure_file_priv.png" class="" title="MySQL安全文件夹配置"><p>将mysql的安全文件夹设置为mysql用户的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> mysql:mysql /mysql_data/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>增加读写权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">777</span> /mysql_data/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/12/10/ubuntu/MySQL-Config-dir.png" class="" title="MySQL配置数据文件夹"><h2 id="QT6-61"><a href="#QT6-61" class="headerlink" title="QT6.61"></a>QT6.61</h2><h3 id="安装完打不开的问题"><a href="#安装完打不开的问题" class="headerlink" title="安装完打不开的问题"></a>安装完打不开的问题</h3><h4 id="解决Qt出现qt-qpa-plugin-Could-not-load-the-Qt-platform-plugin-“xcb”"><a href="#解决Qt出现qt-qpa-plugin-Could-not-load-the-Qt-platform-plugin-“xcb”" class="headerlink" title="解决Qt出现qt.qpa.plugin:Could not load the Qt platform plugin “xcb”"></a>解决Qt出现qt.qpa.plugin:Could not load the Qt platform plugin “xcb”</h4><p>qt.qpa.plugin: Could not load the Qt platform plugin “xcb” in “” even though it was found.<br>This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem.</p><p>Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb.</p><p>Aborted (core dumped)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@node01:/home/Junjie/ovito-basic-3.9.4-x86_64/bin<span class="token comment"># ./ovito</span>qt.qpa.plugin: From <span class="token number">6.5</span>.0, xcb-cursor0 or libxcb-cursor0 is needed to load the Qt xcb platform plugin.qt.qpa.plugin: Could not load the Qt platform plugin <span class="token string">"xcb"</span> <span class="token keyword">in</span> <span class="token string">""</span> even though it was found.This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: minimal, wayland, xcb. 已放弃 <span class="token punctuation">(</span>核心已转储<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h5><p>修改配置文件~/.bashrc：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在最末尾添加如下语句，会在qtcreator启动时，列出详细的错误提示。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">QT_DEBUG_PLUGINS</span><span class="token operator">=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存退出编辑，使配置文件生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动qtcreator会弹出如下详细错误信息：</p><img src="/2023/12/10/ubuntu/Qt-error.png" class="" title="Qt启动错误"><p>在打印的错误信息的最下面，找到了引发错误的真正原因：</p><img src="/2023/12/10/ubuntu/QT-detail.jpg" class="" title="QT详细错误"><img src="/2023/12/10/ubuntu/QT-detail-error.png" class="" title="引发错误的真正原因"><p>也就是Qt动态链接库的问题，当加载libqxcb.so库的时候，还需要加载libxcb-xinerama库。<br>切换到报错libxcb.so所在目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#替换为自己的报错目录</span><span class="token builtin class-name">cd</span> /home/tangdou/Qt/Tools/QtCreator/lib/Qt/plugins/platforms/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行ldd libqxcb.so，查看关联内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ldd libqxcb.so<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/2023/12/10/ubuntu/My-QT-Error.jpg" class="" title="关联内容"><p>libxcb.cursor.so.0没有</p><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>安装libxcb-cursor0库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#如果还存在其他依赖库没有安装，也一并安装。</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libxcb-cursor0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="PDF转图片"><a href="#PDF转图片" class="headerlink" title="PDF转图片"></a>PDF转图片</h2><p>Pdftoppm是一个命令行工具，它可以将PDF文档页面转换为PNG等格式的图片。还可以指定图片的分辨率、比例和裁剪图片。</p><p>根据你的Linux发行版按照如下方式安装pdftoppm。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> poppler-utils     <span class="token punctuation">[</span>On Debian/Ubuntu <span class="token operator">&amp;</span> Mint<span class="token punctuation">]</span><span class="token function">sudo</span> dnf <span class="token function">install</span> poppler-utils     <span class="token punctuation">[</span>On RHEL/CentOS <span class="token operator">&amp;</span> Fedora<span class="token punctuation">]</span><span class="token function">sudo</span> <span class="token function">zypper</span> <span class="token function">install</span> poppler-tools  <span class="token punctuation">[</span>On OpenSUSE<span class="token punctuation">]</span>  <span class="token function">sudo</span> pacman <span class="token parameter variable">-S</span> poppler             <span class="token punctuation">[</span>On Arch Linux<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="将PDF文档转成图片"><a href="#将PDF文档转成图片" class="headerlink" title="将PDF文档转成图片"></a>将PDF文档转成图片</h3><p>将pdf转换为图片的命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pdftoppm -<span class="token operator">&lt;</span>image_format<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pdf_filename<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>image_name<span class="token operator">&gt;</span>pdftoppm -<span class="token operator">&lt;</span>image_format<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pdf_filename<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>image_name<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在下列示例中，我的pdf文件名称是Linux_For_Beginners.pdf，我会将其转换为PNG格式并将图片命为Linux_For_Beginners。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pdftoppm <span class="token parameter variable">-png</span> Linux_For_Beginners.pdf Linux_For_Beginners<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将pdf文件每一页都转换为png格式的图片，如Linux_For_Beginners-1.png、Linux_For_Beginners-2.png等。</p><img src="/2023/12/10/ubuntu/pdftoppm-all.png" class="" title="每一页都转换"><h3 id="将指定范围内的页面转成图片"><a href="#将指定范围内的页面转成图片" class="headerlink" title="将指定范围内的页面转成图片"></a>将指定范围内的页面转成图片</h3><p>命令如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">pdftoppm -&lt;image_format&gt; -f N -l N &lt;pdf_filename&gt; &lt;image_name&gt;pdftoppm -&lt;image_format&gt; -f N -l N &lt;pdf_filename&gt; &lt;image_name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>N为起始页编号， -l N 指定结束页编号。</p><p>在下面的例子中，我们将文件Linux_For_Beginners.pdf的第10页到第15页转换为PNG。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">pdftoppm -png -f 10 -l 15 Linux_For_Beginners.pdf Linux_For_Beginners<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输出的图片名为Linux_For_Beginners-10.png，Linux_For_Beginners-11.png，等。</p><img src="/2023/12/10/ubuntu/change-some.png" class="" title="转换部分页"><h3 id="将pdf文件的第一页转成图片"><a href="#将pdf文件的第一页转成图片" class="headerlink" title="将pdf文件的第一页转成图片"></a>将pdf文件的第一页转成图片</h3><p>命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pdftoppm <span class="token parameter variable">-png</span> <span class="token parameter variable">-f</span> <span class="token number">1</span> <span class="token parameter variable">-l</span> <span class="token number">1</span> Linux_For_Beginners.pdf Linux_For_Beginners<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="调整转换图片的DPI质量"><a href="#调整转换图片的DPI质量" class="headerlink" title="调整转换图片的DPI质量"></a>调整转换图片的DPI质量</h3><p>Pdftoppm默认将PDF页面转换为DPI为150的图片。</p><p>如需要调整，使用参数选项”-rx”和”-ry”。</p><p>在这个例子中，我们将Linux_For_Beginners.pdf转换的图片DPI质量调整为300。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pdftoppm <span class="token parameter variable">-png</span> <span class="token parameter variable">-rx</span> <span class="token number">300</span> <span class="token parameter variable">-ry</span> <span class="token number">300</span> Linux_For_Beginners.pdf Linux_For_Beginners<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要查看pdftoppm中可用和支持的所有选项，请运行以下命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pdftoppm <span class="token parameter variable">--help</span>  <span class="token function">man</span> pdftoppm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="强制结束程序"><a href="#强制结束程序" class="headerlink" title="强制结束程序"></a>强制结束程序</h2><h3 id="找到程序运行的进程号"><a href="#找到程序运行的进程号" class="headerlink" title="找到程序运行的进程号"></a>找到程序运行的进程号</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pgrep <span class="token parameter variable">-f</span> <span class="token string">"software_name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pidof software_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 ps 命令找到进程号</span><span class="token function">ps</span> aux <span class="token operator">|</span> <span class="token function">grep</span> <span class="token string">"process_name"</span><span class="token comment"># 或者使用 pgrep 命令</span>pgrep <span class="token parameter variable">-f</span> <span class="token string">"process_name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>强制 (PID为进程号)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token parameter variable">-9</span> PID<span class="token comment">#或者</span><span class="token function">pkill</span> <span class="token parameter variable">-9</span> <span class="token string">"process_name"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Ubuntu22-04利用lightdm替换gdm3出现的问题或Bug"><a href="#Ubuntu22-04利用lightdm替换gdm3出现的问题或Bug" class="headerlink" title="Ubuntu22.04利用lightdm替换gdm3出现的问题或Bug"></a>Ubuntu22.04利用lightdm替换gdm3出现的问题或Bug</h2><h3 id="查看当前屏幕管理器"><a href="#查看当前屏幕管理器" class="headerlink" title="查看当前屏幕管理器"></a>查看当前屏幕管理器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /etx/X11/default-display-manager<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看当前桌面环境"><a href="#查看当前桌面环境" class="headerlink" title="查看当前桌面环境"></a>查看当前桌面环境</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token environment constant">$DESKTOP_SESSION</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="切换屏幕管理器"><a href="#切换屏幕管理器" class="headerlink" title="切换屏幕管理器"></a>切换屏幕管理器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg-reconfigure gdm3<span class="token function">sudo</span> dpkg-reconfigure lightdm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="推荐下载lightdm屏幕管理器"><a href="#推荐下载lightdm屏幕管理器" class="headerlink" title="推荐下载lightdm屏幕管理器"></a>推荐下载lightdm屏幕管理器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> lightdm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修复lightdm无法锁屏的问题"><a href="#修复lightdm无法锁屏的问题" class="headerlink" title="修复lightdm无法锁屏的问题"></a>修复lightdm无法锁屏的问题</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gsettings get org.gnome.desktop.lockdown disable-lock-screen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>检查disable-lock-screen属性，若输出false则是正常，如果返回值是True，则输入下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gsettings <span class="token builtin class-name">set</span> org.gnome.desktop.lockdown disable-lock-screen <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>更改为flase，</p><p>输入下面命令看是否可以锁屏：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dm-tool lock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若可以实现锁屏，就是图形界面是lightdm而不是gdm3，使用了lightdm 桌面管理器，导致锁屏命令变化，即：设置-&gt;键盘快捷键-&gt;添加自定义快捷键：</p><p>禁用原锁屏键</p><img src="/2023/12/10/ubuntu/lock-pingmu.png" class="" title="禁用锁屏快捷键"><p>自定义快捷键</p><img src="/2023/12/10/ubuntu/zidingyi.png" class="" title="自定义快捷键"><h2 id="输入法无法切换中文"><a href="#输入法无法切换中文" class="headerlink" title="输入法无法切换中文"></a>输入法无法切换中文</h2><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>目前gdm3无法使用中文，我使用的是lightdm屏幕管理器</p><p>使用搜狗输入法</p><p>安装搜狗输入法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> dpkg <span class="token parameter variable">-i</span> sogoupinyin_4.0.1.2800_x86_64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主要是因为缺少包导致的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2<span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libgsettings-qt1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li>[1] <a href="https://blog.csdn.net/qq_39779233/article/details/127290795">wonghome. Ubuntu 18.04 安装搜狗输入法 [EB/OL].</a></li><li>[2] <a href="https://blog.csdn.net/yuzhongmanbu99/article/details/127944446">雨中漫步-99. ubuntu系统安装好搜狗输入法后只能输入英文，无法输入中文的解决方案 [EB/OL]. </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery</title>
      <link href="/2023/12/10/hexo-matery/"/>
      <url>/2023/12/10/hexo-matery/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h2><h3 id="安装前置工具"><a href="#安装前置工具" class="headerlink" title="安装前置工具"></a>安装前置工具</h3><p>首先需要安装</p><ul><li><p><a href="https://nodejs.org/en">Node.js</a>((Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本))</p></li><li><p><a href="https://git-scm.com/">Git</a></p></li></ul><p>建议将Node.js和Git都放进环境变量</p><img src="/2023/12/10/hexo-matery/environment-variables.png" class="" title="环境变量"><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> <span class="token parameter variable">-g</span> hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init <span class="token operator">&lt;</span>folder<span class="token operator">&gt;</span><span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">&gt;</span><span class="token function">npm</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>网站配置信息位于_config.yml</p><p>资源文件夹位于source/</p><p>主题文件夹位于themes/</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>参数配置请参考</p><p><a href="https://hexo.io/zh-cn/docs/configuration">hexo官方文档-配置</a></p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="初始化init"><a href="#初始化init" class="headerlink" title="初始化init"></a>初始化init</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init <span class="token punctuation">[</span>folder<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="新建一篇文章new"><a href="#新建一篇文章new" class="headerlink" title="新建一篇文章new"></a>新建一篇文章new</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><p>例如<code>hexo new "post title with whitespace"</code></p><h4 id="生成静态文件generate"><a href="#生成静态文件generate" class="headerlink" title="生成静态文件generate"></a>生成静态文件generate</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以简写为<code>hexo g</code></p><h4 id="启动服务server"><a href="#启动服务server" class="headerlink" title="启动服务server"></a>启动服务server</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><p>可以简写为<code>hexo s</code></p><h4 id="部署网站deploy"><a href="#部署网站deploy" class="headerlink" title="部署网站deploy"></a>部署网站deploy</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以简写为<code>hexo d</code></p><h4 id="清除缓存文件-db-json-和已生成的静态文件-public-。clean"><a href="#清除缓存文件-db-json-和已生成的静态文件-public-。clean" class="headerlink" title="清除缓存文件 (db.json) 和已生成的静态文件 (public)。clean"></a>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。clean</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="显示版本version"><a href="#显示版本version" class="headerlink" title="显示版本version"></a>显示版本version</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="在-GitHub-Pages-上部署-Hexo"><a href="#在-GitHub-Pages-上部署-Hexo" class="headerlink" title="在 GitHub Pages 上部署 Hexo"></a>在 GitHub Pages 上部署 Hexo</h4><h5 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h5><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。<code>npm install hexo-deployer-git --save</code></li><li>在 <code>_config.yml</code> 中添加以下配置（如果配置已经存在，请将其替换为如下）:</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:  type: <span class="token function">git</span>  repo: https://github.com/<span class="token operator">&lt;</span>username<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>project<span class="token operator">&gt;</span>  <span class="token comment"># example, https://github.com/hexojs/hexojs.github.io</span>  branch: gh-pages<span class="token punctuation">(</span>你的分支名<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>执行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</li><li>浏览 <code>&lt;GitHub 用户名&gt;.github.io</code> 检查你的网站能否运作。</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="https://hexo.io/zh-cn/">hexo官方文档</a></li></ul><h2 id="配置matery主题"><a href="#配置matery主题" class="headerlink" title="配置matery主题"></a>配置matery主题</h2><h3 id="仓库位置"><a href="#仓库位置" class="headerlink" title="仓库位置"></a>仓库位置</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a></p><p>将此仓库clone到你站点的themes/文件夹下</p><p>按照blinkfox大神的说明配置即可</p><h2 id="图片无法显示"><a href="#图片无法显示" class="headerlink" title="图片无法显示"></a>图片无法显示</h2><p>修改</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">post_asset_folder: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><p>安装插件:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-image-link <span class="token parameter variable">--save</span><span class="token function">npm</span> <span class="token function">install</span> hexo-renderer-marked <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>启用:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># _config.yml</span>post_asset_folder: <span class="token boolean">true</span>marked:  prependRoot: <span class="token boolean">true</span>  postAsset: <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启用后，资源图片将会被自动解析为其对应文章的路径。</p><p>需要注意的是:图片名最好是英文名称,如果你自己重命名了图片为中文名称的话，将出现不可预知的错误。</p><p>例如： <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img src="/2020/01/02/foo/image.jpg"&gt;</code> 。</p><h3 id="使用typora优化体验"><a href="#使用typora优化体验" class="headerlink" title="使用typora优化体验"></a>使用typora优化体验</h3><img src="/2023/12/10/hexo-matery/Typora-picture-configuration.png" class="" title="Typora图像设置"><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="http://edulinks.cn/2020/03/14/20200314-write-hexo-with-typora/">Hexo博客写作与图片处理的经验</a></li><li>[2] <a href="https://hexo.io/zh-cn/docs/asset-folders.html">Hexo官方文档</a></li></ul><h2 id="代码块问题"><a href="#代码块问题" class="headerlink" title="代码块问题"></a>代码块问题</h2><p>正常配置代码块会变成这样</p><img src="/2023/12/10/hexo-matery/ugly-code-blocks.png" class="" title="难看的代码块"><p>除了使用blinkfox大神的配置外</p><img src="/2023/12/10/hexo-matery/Configuration-of-code-blocks-by-blinkfox-master.png" class="" title="blinkfox大神代码块的配置"><p>还应该参考hexo官方文档给出的解决方案</p><img src="/2023/12/10/hexo-matery/hexo-official-document-about-prismjs-configuration.png" class="" title="hexo官方文档关于prismjs的配置"><p>主要修改<code>syntax_highlighter</code>和<code>line_threshould</code>即可</p><p>修改后的代码块</p><img src="/2023/12/10/hexo-matery/Modified-code-block.png" class="" title="修改后的代码块"><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul><li>[1] <a href="https://hexo.io/zh-cn/docs/syntax-highlight#PrismJS">hexo关于代码高亮的官方文档</a></li><li>[2] <a href="https://github.com/KeyenZhou/hexo-theme-matery/blob/develop/README_CN.md">hexo-matery主题配置</a></li></ul><h2 id="hexo传输过程的警告和error"><a href="#hexo传输过程的警告和error" class="headerlink" title="hexo传输过程的警告和error"></a>hexo传输过程的警告和error</h2><h3 id="Windows下Git使用警告：warning：LF-will-be-replaced-by-CRLF-in-××××-××"><a href="#Windows下Git使用警告：warning：LF-will-be-replaced-by-CRLF-in-××××-××" class="headerlink" title="Windows下Git使用警告：warning：LF will be replaced by CRLF in ××××.××"></a>Windows下Git使用警告：warning：LF will be replaced by CRLF in ××××.××</h3><p><strong>1、不同操作系统下，处理行尾结束符的方法是不同的</strong>：</p><p>　windows下：CRLF（表示句尾使用回车换行两个字符，即windows下的”\r\n”换行）</p><p>​    unix下：LF（表示句尾，只使用换行）</p><p>​    mac下：CR（表示只使用回车）</p><p><strong>2、Git下处理“换行”（line ending）</strong></p><p>　　core.autocrlf是git中负责处理line ending的变量，可以设置3个值：true，false，inout。</p><p>（1）设置为true <code>git config --global core.autocrlf true</code></p><p>​     当设置成true时，这意味着你在任何时候添加(add)文件到git仓库时，git都会视为它是一个文本文件(text file)。</p><p>　　　它将把crlf变成LF。</p><p>（2）设置为false <code>git config --global core.autocrlf false</code></p><p>  　当设置成false时，line endings将不做转换操作。文本文件保持原来的样子。</p><p>（3）设置为input时，添加文件git仓库时，git把crlf编程lf。当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置。</p><h2 id="部署评论模块"><a href="#部署评论模块" class="headerlink" title="部署评论模块"></a>部署评论模块</h2><h3 id="livere"><a href="#livere" class="headerlink" title="livere"></a>livere</h3><p>我们可以看到/themes/hexo-theme-matery/_config.yml</p><p>有如下配置信息</p><img src="/2023/12/10/hexo-matery/livere-config.png" class="" title="livere配置"><p>在来必力网站注册:</p><p><a href="https://www.livere.com/">来必力</a></p><p>注册好账号之后打开：后台管理——&gt;代码管理 复制 data-uid的值，如下图</p><img src="/2023/12/10/hexo-matery/Laibili-management-interface.png" class="" title="来必力管理界面"><p>将data-uid的值填入_config.yml配置文件里面的uid即可。</p>]]></content>
      
      
      <categories>
          
          <category> hexo-matery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/12/10/hello-world/"/>
      <url>/2023/12/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
